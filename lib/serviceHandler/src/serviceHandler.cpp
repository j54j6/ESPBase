#include "serviceHandler.h"

/*
    Constructor / Destructor
*/

ServiceHandler::ServiceHandler(Filemanager* FM, WiFiManager* wifiManager)
{
    this->FM = FM;
    this->wifiManager = wifiManager;
}

ServiceHandler::~ServiceHandler()
{
    this->udpControl.stop();
    this->udpControl.~udpManager();
}

/*
    Protected functions
*/

String ServiceHandler::formatComMessage(bool request, bool generateId, String serviceName, String MAC, String ip, String port, String id)
{
    /*
    {
        "type": "request",
        "serviceName" : "notSet",
        "mac" : "<<MACAddress>>",
        "ip" : "<<IPAddress>>",
        "servicePort" : "<<port>>"
        "id" : "<<id>>" //id is randomGenerated by millis()+RandomNumber
    }
    */
    /*
    Serial.println("********************************");
    Serial.print("Request: ");
    Serial.println(request);
    Serial.print("GenerateID: ");
    Serial.println(generateId);
    Serial.print("serviceName: ");
    Serial.println(serviceName);
    Serial.print("MAC: ");
    Serial.println(MAC);
    Serial.print("IP: ");
    Serial.println(ip);
    Serial.print("servicePort: ");
    Serial.println(servicePort);
    Serial.print("GivenID: ");
    Serial.println(givenID);
    Serial.println("********************************");
    */


    long genId = millis() + random(20, 2145895698);
    lastId = genId;



    String output = "{\"type\" : \"";
    if(request)
    {
        output += "request";
    }
    else
    {
        output += "answer";
    }
    output += "\",";
    output += "\"serviceName\" : \"";
    output += serviceName;
    output += "\", ";
    output += "\"mac\" : \"";
    output += MAC;
    output += "\", ";
    output += "\"ip\" : \"";
    output += ip;
    output += "\", ";
    output += "\"servicePort\" : \"";
    output += port;
    if(!generateId)
    {
        output += "\"";
        output += "}";
    }
    else
    {
        if(id == "n.S")
        {
            output += "\",";
            output += "\"id\" : \"";
            output += genId;
            output += "\"}";
        }
        else
        {
            output += "\",";
            output += "\"id\" : \"";
            output += id;
            output += "\"}";
        } 
    }
    /*
    Serial.println("Output String: ");
    Serial.println(output);
    Serial.println("********************************");
    */
    return output;
}

String ServiceHandler::getExternalServiceFilename(const char* serviceName, bool fallback)
{
    String cacheName = serviceName;
    cacheName.replace(" ", "");

    String rfilename = externalServicesPath;
    rfilename += cacheName;
    if(fallback)
    {
        rfilename += "-fallback";
    }
    rfilename += ".json";
    rfilename.replace(" ", "");
    return rfilename;
}

bool ServiceHandler::createInternalServicesBasicConfigFile()
{
    FM->mount();
    if(!FM->fExist(offeredServicesPath))
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "createConfigFile", "Config File doesn't exist - try to create", 1);
        #endif 

        if(FM->createFile(offeredServicesPath))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "createConfigFile", "File created!");
            #endif 
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "createConfigFile", "Can't create File! - return false", 2);
            #endif
            return false;
        }

        if(FM->writeJsonFile(offeredServicesPath, serviceConfigBlueprint, 1))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "createConfigFile", "Config Fallback written - return true");
            #endif
            return true;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "createConfigFile", "Can't write in File!");
            #endif
            return false;
        }
        return false;  
    }
    else
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "createConfigFile", "File already exist - SKIP!");
        #endif
        return true;
    }
    return false;
}

void ServiceHandler::handleRequests()
{
    return;
}

ulong ServiceHandler::getLastGeneratedId()
{
    return lastId;
}

StaticJsonDocument<425> ServiceHandler::getLastData()
{
    return udpLastReceivedDataDocument;
}

/*
    Public functions
*/

bool ServiceHandler::beginListen()
{
    createInternalServicesBasicConfigFile();
    if(udpControl.begin())
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "beginListen", "NetworkIdent Service started");
        #endif
        return true;
    }
    else
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "beginListen", "Can't start NetworkIdent - udpControl return false!", 2);
        #endif
        return false;
    }
    return false;
}

void ServiceHandler::stopListen()
{
    udpControl.stop();
    #ifdef J54J6_LOGGING_H
        logger logging;
        logging.SFLog(className, "stopListen", "UDP Listener stopped", 0);
    #endif
}

/*
    Service Management
*/

bool ServiceHandler::addService(bool selfOffered, bool fallback, const char* serviceName, const char* port, IPAddress ip)
{
    if(selfOffered)
    {
        /*
           internal Services path
        */
       FM->begin();
        if(FM->fExist(offeredServicesPath))
        {
            if(checkForService(serviceName))
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "addService", "Service already exist - SKIP", 0);
                #endif 
                return true;
            }
            const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
            StaticJsonDocument<capacity> cacheDocument;

            //cacheDocument = FM->readJsonFile(serviceListPath);
            String data = FM->readFile(offeredServicesPath);

            if(!data.isEmpty())
            {
                deserializeJson(cacheDocument, data);
            }
            cacheDocument[serviceName] = port;

            FM->writeJsonFile(offeredServicesPath, cacheDocument);
            if(checkForService(serviceName))
            {
                return true;
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "addService", "An Error occured while adding the Service please check! -  Service can't be added", 2);
                #endif
                return false;
            }
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "addService", "Can't check for Service - ServiceList File doesn't exist!", 1);
            #endif
            return false;
        }
    }
    else
    {
        /*
            External Services path
        */
        if(ip != IPAddress(0,0,0,0) && String(serviceName) != "n.S" && String(port) != "-1")
        {
            //create File
            if(!FM->fExist(getExternalServiceFilename(serviceName, fallback).c_str()));
            {
                FM->createFile(getExternalServiceFilename(serviceName, fallback).c_str());
            }
            bool setIp = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "ip", ip.toString().c_str());
            bool setMac = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "mac", "n.S");
            bool setPort = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "port", port);

            if(!setIp || !setMac || !setPort)
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "addService", "One or more parameter can't be saved - create or append has failed!", 2);
                #endif
                return false;
            }
            else
            {
                if(checkForService(serviceName) == 2)
                {
                    #ifdef J54J6_LOGGING_H
                        logger logging;
                        logging.SFLog(className, "addService", "Service successfully added");
                    #endif
                    return true;
                }
                else
                {
                    #ifdef J54J6_LOGGING_H
                        logger logging;
                        logging.SFLog(className, "addService", "File could not be created! - Can't fnd Service after add process! - return false", 2);
                    #endif
                    return false;
                }  
            }
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "addService", "Can't add Service - one or more parameter not set!", 1);
            #endif
            return false;
        }   
    }
    return false;
}

short ServiceHandler::autoAddService(const char* serviceName)
{
    if(!autoAddRunning && strcmp(serviceName, "n.S") != 0 && strcmp(lastAutoAddRequest.serviceName, "n.S") == 0) //init. autoAdd and set all Variables
    {
        //check if service already is registered - main Cfg
        if(!FM->fExist(getExternalServiceFilename(serviceName).c_str()))
        {
            //init main CFG create
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "Init. creation of mainCFG for Service \"";
                message += serviceName;
                message += "\"";
                logging.SFLog(className, "autoAddService", message.c_str(), 0);
            #endif

            searchForService(serviceName);
            lastAutoAddRequest.createdAt = millis();
            lastAutoAddRequest.deleteAfter = timeoutAfterAutoAddWillEnd;
            lastAutoAddRequest.id = getLastGeneratedId(); 
            lastAutoAddRequest.searchType = 4; //autoAdd function is used
            lastAutoAddRequest.serviceName = serviceName;
            autoAddRunning = true; //start autoAdd loop part
            return 2;
        }
        else
        {
            if(!FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    String message = "Init. creation of FallbackCFG for Service \"";
                    message += serviceName;
                    message += "\"";
                    logging.SFLog(className, "autoAddService", message.c_str(), 0);
                #endif

                //init main CFG create
                searchForService(serviceName);
                lastAutoAddRequest.createdAt = millis();
                lastAutoAddRequest.deleteAfter = timeoutAfterAutoAddWillEnd;
                lastAutoAddRequest.id = getLastGeneratedId(); 
                lastAutoAddRequest.searchType = 4; //autoAdd function is used
                lastAutoAddRequest.serviceName = serviceName;
                lastAutoAddRequest.isFallback = true;
                autoAddRunning = true; //start autoAdd loop part
                return 2;
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    String message = "Can't create CFG for Service \"";
                    message += serviceName;
                    message += "\" - Fallback and Main already defined";
                    logging.SFLog(className, "autoAddService", message.c_str(), 0);
                #endif
                return 3;
            } 
        }        
    }
    else if(!autoAddRunning && strcmp(serviceName, "n.S") != 0) //serviceName is not "n.S"
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "autoAddService", "Can't add Service \"n.S\" - it's a placeholder!", 1);
        #endif
        return 0;
    }
    else //autoAdd already running - do loop stuff to check for any responses and add new service if needed
    {
        if(lastAutoAddRequest.id == 0) //lastRequest is > timeout - disable autoRun
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "autoAddService", "Can't add Service - timeout reached! - return false", 1);
            #endif
            autoAddRunning = false;
            return 0;
        }
        else if(lastAutoAddRequest.id != 0 && lastAutoAddRequest.searchType != 4) //lasRequest was not set by function AutoAdd
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "autoAddService", "Schedule Problem - lastRequest not set by autoAdd - wrong searchType - disable autoAdd loop and return false", 1);
            #endif
            autoAddRunning = false;
            return 0;
        }
        
        //working normal
        if(lastAutoAddRequest.id != 0 && lastAutoAddRequest.searchType == 4)
        {
            StaticJsonDocument<425> lastFetched = getLastData();

            /*
                Check if lastFetched Data have the right Syntax and Values needed to add new Service
            */
            if(!lastFetched.containsKey("id") || !lastFetched.containsKey("serviceName") || !lastFetched.containsKey("ip") || !lastFetched.containsKey("mac") || !lastFetched.containsKey("servicePort"))
            {
                return 2;
            }
            else
            {
                /*
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "autoAddService", "Received useable Packet", -1);
                #endif

                */
                //lastReceived Packet does contain all needed keys to create a new Service - check for id and serviceName
                String castedLastRequestID = String(lastAutoAddRequest.id);
                String castedLastReceivedID = lastFetched["id"];

                castedLastReceivedID.replace(" ", "");
                castedLastRequestID.replace(" ", "");

                if(castedLastRequestID == castedLastReceivedID)
                {
                    //same id - start adding new service
                    if(!lastAutoAddRequest.isFallback)
                    {
                        /*
                            Creating main Service Cfg
                        */
                        if(!FM->fExist(getExternalServiceFilename(lastAutoAddRequest.serviceName, false).c_str()))
                        {
                            //create mainServiceCfg
                            #ifdef J54J6_LOGGING_H
                                logger logging;
                                logging.SFLog(className, "autoAddService", "Creating new Service Main CFG");
                            #endif

                            if(!FM->createFile(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str()))
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create new File - create File returns false! - ERROR!", 2);
                                #endif
                                error.error = true;
                                error.ErrorCode = 378;
                                error.message = "Can't create new File - createFile() returns false!";
                                error.priority = 5;
                                lastAutoAddRequest.reset();
                                autoAddRunning = false;
                                return 0;
                            }
                            else
                            {
                                bool ipAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str(), "ip", lastFetched["ip"]);
                                bool macAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str(), "mac", lastFetched["mac"]);
                                bool portAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str(), "port", lastFetched["servicePort"]);

                                if(ipAdded && macAdded && portAdded)
                                {
                                    #ifdef J54J6_LOGGING_H
                                        logger logging;
                                        String message = "New Service Main CFG \"";
                                        message += lastAutoAddRequest.serviceName;
                                        message += "\" successfully added - return true";
                                        logging.SFLog(className, "autoAddService", message.c_str());
                                    #endif

                                    String data = FM->readFile(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str());

                                    //for debug
                                    /*
                                    Serial.println("--------------------------------");
                                    Serial.println(data);
                                    Serial.println("--------------------------------");
                                    */


                                    lastAutoAddRequest.reset();
                                    autoAddRunning = false;

                                   
                                    return 1;
                                }
                                else
                                {
                                    #ifdef J54J6_LOGGING_H
                                        logger logging;
                                        String message = "New Service Main CFG \"";
                                        message += lastAutoAddRequest.serviceName;
                                        message += "\" can't be added - Error while insert JSON- return false";
                                        logging.SFLog(className, "autoAddService", message.c_str(), 2);
                                    #endif
                                    lastAutoAddRequest.reset();
                                    autoAddRunning = false;
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            /*
                                File already exist - check if configured too (contains any key/value) and end autoAdd
                            */
                            if(strcmp(FM->readJsonFileValue(getExternalServiceFilename(lastAutoAddRequest.serviceName).c_str(), "serviceName"), "") != 0) //file has config
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create Servicefile - service already configured - stop AutoAdd - return true", 1);
                                #endif
                                autoAddRunning = 0;
                                return 1;
                            }
                            else
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create Servicefile - servicefile already exist - but not correct configured! - stop AutoAdd - return false", 2);
                                #endif
                                autoAddRunning = 0;
                                return 0;
                            }   
                        }
                    }
                    else 
                    {
                        /*
                            Creating Fallback Service CFG
                        */

                        if(!FM->fExist(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str()))
                        {
                            //create mainServiceCfg
                            #ifdef J54J6_LOGGING_H
                                logger logging;
                                logging.SFLog(className, "autoAddService", "Creating new Service Fallback CFG");
                            #endif

                            if(!FM->createFile(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str()))
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create new File - create File returns false! - ERROR!", 2);
                                #endif
                                error.error = true;
                                error.ErrorCode = 378;
                                error.message = "Can't create new File (fallback service) - createFile() returns false!";
                                error.priority = 5;
                                lastAutoAddRequest.reset();
                                autoAddRunning = false;
                                return 0;
                            }
                            else
                            {
                                bool ipAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "ip", lastFetched["ip"]);
                                bool macAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "mac", lastFetched["mac"]);
                                bool portAdded = FM->appendJsonKey(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "port", lastFetched["servicePort"]);

                                if(ipAdded && macAdded && portAdded)
                                {
                                    #ifdef J54J6_LOGGING_H
                                        logger logging;
                                        String message = "New Service Fallback CFG \"";
                                        message += lastAutoAddRequest.serviceName;
                                        message += "\" successfully added - return true";
                                        logging.SFLog(className, "autoAddService", message.c_str());
                                    #endif

                                    String data = FM->readFile(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str());

                                    //for debug
                                    /*
                                    Serial.println("--------------------------------");
                                    Serial.println(data);
                                    Serial.println("--------------------------------");
                                    */

                                    lastAutoAddRequest.reset();
                                    autoAddRunning = false;
                                    
                                    
                                    
                                    return 1;
                                }
                                else
                                {
                                    #ifdef J54J6_LOGGING_H
                                        logger logging;
                                        String message = "New Service Fallback CFG \"";
                                        message += lastAutoAddRequest.serviceName;
                                        message += "\" can't be added - Error while insert JSON- return false";
                                        logging.SFLog(className, "autoAddService", message.c_str(), 2);
                                    #endif
                                    lastAutoAddRequest.reset();
                                    autoAddRunning = false;
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            /*
                                File already exist - check if configured too (contains any key/value) and end autoAdd
                            */
                            if(strcmp(FM->readJsonFileValue(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "serviceName"), "") != 0)
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create Service Fallback file - service already configured - stop AutoAdd - return true", 1);
                                #endif
                                autoAddRunning = 0;
                                return 1;
                            }
                            else
                            {
                                #ifdef J54J6_LOGGING_H
                                    logger logging;
                                    logging.SFLog(className, "autoAddService", "Can't create Service Fallback file - servicefile already exist - but not correct configured! - stop AutoAdd - return false", 2);
                                #endif
                                autoAddRunning = 0;
                                return 0;
                            }   
                        }
                    }//create main or fallback cfg - else end - create fallback(else)
                } //id of lastRequest and lastFetched are matching if ot - do nothing
            }//lastFetched contains all keys (else block) 
        }//check for correct id and searchType - if not match - do nothing   
    } //loop stuff - else

return 2;
}

bool ServiceHandler::delService(const char* serviceName, bool selfOffered, bool fallback)
{
    if(selfOffered)
    {
        /*
            Delete an internal Service
        */
       if(!FM->fExist(offeredServicesPath))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "delService", "Can't delete Service, serviceList doesn't exist!", 1);
            #endif
            return false;
        }

        if(!checkForService(serviceName))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "delService", "Can't delete Service, serviceList doesn't contains the specified Service! - SKIP", 1);
            #endif
            return true;
        }

        const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
        DynamicJsonDocument cacheDocument(capacity);

        cacheDocument = FM->readJsonFile(offeredServicesPath);

        cacheDocument.remove(serviceName);

        if(checkForService(serviceName))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "delService", "An Error occured while deleting the Service - please check!", 2);
            #endif
            return false;
        }
        #ifdef J54J6_LOGGING_H
            logger logging;
            logging.SFLog(className, "delService", "Service successfully deleted!");
        #endif
        return true;
    }
    else
    {
        /*
            delete an external Service
        */
        if(FM->fDelete(getExternalServiceFilename(serviceName, fallback).c_str()))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "delService", "Service removed");
            #endif
            return true;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "delService", "Can't remove Service - function returns false", 2);
            #endif
        }
    }
    return false;
}

/*
    Get Stuff
*/

IPAddress ServiceHandler::getServiceIP(const char* serviceName, bool fallback)
{
    IPAddress ip;
    if(!fallback)
    {
        if(ip.fromString(String(FM->readJsonFileValue(getExternalServiceFilename(serviceName).c_str(), "ip"))))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned IP for Service \"";
                message += serviceName;
                message += "\" with IP \"";
                message += ip.toString();
                message += "\" - success";
                logging.SFLog(className, "getServiceIP", message.c_str());
            #endif 
            return ip;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServiceIP", "Can't read IP! - return errorIP", 2);
            #endif 
            return IPAddress(0,0,0,0);
        }
    }
    else
    {
        if(ip.fromString(String(FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "ip"))))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned IP for Service \"";
                message += serviceName;
                message += "\" with IP \"";
                message += ip.toString();
                message += "\" - success";
                logging.SFLog(className, "getServiceIP", message.c_str());
            #endif 
            return ip;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServiceIP", "Can't read IP! - return errorIP", 2);
            #endif 
            return IPAddress(0,0,0,0);
        }
    }
    return IPAddress(0,0,0,0);
}

String ServiceHandler::getServiceMAC(const char* serviceName, bool fallback)
{
    if(!fallback)
    {   
        String mac = FM->readJsonFileValue(getExternalServiceFilename(serviceName).c_str(), "mac");
        if(mac != "")
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned MAC for Service \"";
                message += serviceName;
                message += "\" with MAC \"";
                message += mac;
                message += "\" - success";
                logging.SFLog(className, "getServiceMAC", message.c_str());
            #endif 
            return mac;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServiceMAC", "Can't read MAC! - return \"failed\"", 2);
            #endif 
            return "failed";
        }
    }
    else
    {
        String mac = FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "mac");
        if(mac != "")
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned MAC for Service \"";
                message += serviceName;
                message += "\" with MAC \"";
                message += mac;
                message += "\" - success";
                logging.SFLog(className, "getServiceMAC", message.c_str());
            #endif 
            return mac;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServiceMAC", "Can't read MAC! - return \"failed\"", 2);
            #endif 
            return "failed";
        }
    }
    return "failed";
}

int ServiceHandler::getServicePort(const char* serviceName, bool fallback)
{
    if(!fallback)
    {   
        String port = FM->readJsonFileValue(getExternalServiceFilename(serviceName).c_str(), "port");
        if(port != "")
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned Port for Service \"";
                message += serviceName;
                message += "\" with Port \"";
                message += port;
                message += "\" - success";
                logging.SFLog(className, "getServicePort", message.c_str());
            #endif 
            return port.toInt();
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServicePort", "Can't read Port! - return -1", 2);
            #endif 
            return -1;
        }
    }
    else
    {
        String port = FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "port");
        if(port != "")
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                String message = "returned Port for Service \"";
                message += serviceName;
                message += "\" with Port \"";
                message += port;
                message += "\" - success";
                logging.SFLog(className, "getServicePort", message.c_str());
            #endif 
            return port.toInt();
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "getServicePort", "Can't read Port! - return -1", 2);
            #endif 
            return -1;
        }
    }
    return -1;
}

short ServiceHandler::checkForService(const char* serviceName, bool onlyExternal)
{
    short result = 0;

    /*
        Check for internal Service
    */
    if(!onlyExternal)
    {
        bool skip = false;
        if(!FM->fExist(offeredServicesPath))
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "checkForService", "Can't check for internal Service - serviceFile doesn't exist!", 2);
            #endif
        }
        if(!skip)
        {
            const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
            DynamicJsonDocument cacheDocument(capacity);

            cacheDocument = FM->readJsonFile(offeredServicesPath);
            /*  
                Serial.println(".......................");
                Serial.println(FM->readFile(serviceListPath));
                Serial.println(".......................");
            */  
            if(cacheDocument.containsKey(serviceName))
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    String message = "Service \"";
                    message += serviceName;
                    message += "\" exist! - result = 1";
                    logging.SFLog(className, "checkForService", message.c_str());
                #endif
                result = 1;
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    String message = "Can't find Service \"";
                    message += serviceName;
                    message += "\" in serviceList - return false";
                    logging.SFLog(className, "checkForService", message.c_str());
                #endif
            }
        }
    }

    /*
        Check for external Service
    */
    if(FM->fExist(getExternalServiceFilename(serviceName, false).c_str()) || FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
    {
        switch (result)
        {
        case 0:
            result = 2;
            break;
        case 1:
            result = 3;
        default:
            break;
        }
    }

    #ifdef J54J6_LOGGING_H
        logger logging;
        String message = "Return State for Service \"";
        message += serviceName;
        message += "\": ";
        message += result;
        logging.SFLog(className, "checkForService", message.c_str());
    #endif
    return result;
}

bool ServiceHandler::changeConfigValue(const char* serviceName, const char* toChangeKey, const char* newValue, bool changeInternalService, bool changeFallback)
{
    if(changeInternalService)
    {
        /*
            Edit internal Services File (only ServiceName and Port can be changed!)
        */
        if(FM->fExist(offeredServicesPath))
        {
           return FM->changeJsonValueFile(offeredServicesPath, toChangeKey, newValue);
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                logging.SFLog(className, "changeConfigValue", "Can't change Value  File doesn't exist!", 2);
            #endif
            return false;
        }
    }
    else
    {
        /*
            Edit external Service File
        */
        if(changeFallback)
        {
            /*
                Edit Fallback CFG
            */
            if(FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
            {
                return FM->changeJsonValueFile(getExternalServiceFilename(serviceName, true).c_str(), toChangeKey, newValue);
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "changeConfigValue", "Can't change Value - Fallback file doesn't exist!", 2);
                #endif
                return false;
            }
        }
        else
        {
            /*
                Edit Main CFG
            */
            if(FM->fExist(getExternalServiceFilename(serviceName, false).c_str()))
            {
                return FM->changeJsonValueFile(getExternalServiceFilename(serviceName, false).c_str(), toChangeKey, newValue);
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    logging.SFLog(className, "changeConfigValue", "Can't change Value - Main file doesn't exist!", 2);
                #endif
                return false;
            }
        }
    }
    return false;
}

void ServiceHandler::searchForService(const char* serviceName, bool generateId, IPAddress ip, int port)
{
    String message;
    if(!generateId)
    {
        message = formatComMessage(true, false, serviceName);
    }
    else
    {
        message = formatComMessage(true, true, serviceName);
    }
    
    udpControl.sendUdpMessage(message.c_str(), ip, port);
}

void ServiceHandler::loop()
{
    //check for new Packets with UDPControl Class on <<NetworkIdentPort>>
    udpControl.run();

    //if this class is Disabled - end function
    if(classDisabled)
    {
        return;
    }

    if(autoAddRunning)
    {
        autoAddService();
        lastAutoAddRequest.loop();
    }

    //get new Packets if there are new ones - if nothing new there is an empty pack delivered
    udpPacketResolve* lastResolve = udpControl.getLastUDPPacketLoop();

    //If there is any new Data -> Content != NULL -> clean all fragments delivered with the protocol -> in this Case only char until packackgeSize[n] will be readed all other are removed
    if(lastResolve->udpContent != "NULL")
    {
        lastResolve->clean(); //delete fragments at the end of document
    }
    
    //If there are no new Data UDPContent=NULL -> end function
    if(lastResolve->udpContent == "NULL")
    {
        return;
    }
    
    //for debug only
    /*
    Serial.println("---------------------------------");
    Serial.println("UDP Content: ");
    Serial.println(lastResolve->udpContent);
    Serial.println("---------------------------------");
    */

    //create a Json Document from the String given in the last Resolve -> result saved in <<error>>
    DeserializationError error = deserializeJson(udpLastReceivedDataDocument, lastResolve->udpContent);

    /*
        This part called if the incoming data doesnt have the correct syntax - most Error showing Serial is "incomplete Input"
        
        In this Case you only get a Warn and the function ends - if you use this port for another thins unlike NetworkIdent you can use the data properly
    */
    if(error)
    {
        #ifdef J54J6_LOGGING_H
            logger logging;
            String message = "Can't parse last UDP Content to Json - Json returned: \n!";
            message += error.c_str();
            message += "\n";
            logging.SFLog(className, "loop", message.c_str(), 1);
        #endif
        return;
    }
    else
    {
        //check for any constructions

        /*
            If you are here you have a correct Json Data package received
            

            Basicly this "else" block does:
                First check if the Json Package includes:
                    - serviceName key 
                    - type key
                If this is not included the function will end

                If both keys are existing:
                    Check if the "type" value is "request" or "answer"

                If type is an request (type = "request")
                    First check for own Services the device offer to others
                    If nothing found saved services will be searched - if there is an service Matching <<serviceName>> - this will be sended
                If type is an answer (type = "answer")
                    Check if ID is the same sended by NetworkIdent
                        if true:
                            try to add the new Service data
                        else
                            function ends
                    at last step:
                        Test for Service
        
        */
        if(!udpLastReceivedDataDocument.containsKey("type") || !udpLastReceivedDataDocument.containsKey("serviceName"))
        {
            //If the parsed Document does not contain "type" and "serviceName" - drop the package and end function

            return;
        }


        //cache the Servicename to remove space in Names - because of earlier Problems i prevent double Services or basic mistakes
        String serviceNameCached = udpLastReceivedDataDocument["serviceName"];
        serviceNameCached.replace(" ", "");
        

        if(udpLastReceivedDataDocument["type"] == "request")
        {
            /*
                request Section

                First check for self offered Services matching the Json.serviceName
                if not
                check for interal saved addresses matching the json.servername
            */

            if(checkForService(udpLastReceivedDataDocument["serviceName"]) != 0)
            {
                #ifdef J54J6_LOGGING_H
                    
                    logger logging;
                    String message = "Service ";
                    message += serviceNameCached;
                    message += "exist - return true";
                    logging.SFLog(className, "loop", message.c_str(), 1);
                #endif
                
                String fmsg;
                if(udpLastReceivedDataDocument.containsKey("id"))
                {
                    #ifdef J54J6_LOGGING_H
                        logger logging;
                        logging.SFLog(className, "loop", "ID will be appended", -1);
                    #endif

                    if(checkForService(udpLastReceivedDataDocument["serviceName"]) == 1 || checkForService(udpLastReceivedDataDocument["serviceName"]) == 3)
                    {
                        fmsg = formatComMessage(false, false, udpLastReceivedDataDocument["serviceName"], WiFi.macAddress(), wifiManager->getLocalIP(), FM->readJsonFileValue(offeredServicesPath, serviceNameCached.c_str()), udpLastReceivedDataDocument["id"]);
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                    }
                    else
                    {
                        /*
                        fmsg = formatComMessage(false, false, udpLastReceivedDataDocument["serviceName"], getServiceMAC(udpLastReceivedDataDocument["serviceName"]), getServiceIP(udpLastReceivedDataDocument["serviceName"]).toString() , FM->readJsonFileValue(externalServicesPath, serviceNameCached.c_str()));
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                        */
                    }
                }
                else
                {
                    #ifdef J54J6_LOGGING_H
                        logger logging;
                        logging.SFLog(className, "loop", "ID will generated", -1);
                    #endif
                    
                    if(checkForService(udpLastReceivedDataDocument["serviceName"]) == 1 || checkForService(udpLastReceivedDataDocument["serviceName"]) == 3)
                    {
                        fmsg = formatComMessage(false, true, udpLastReceivedDataDocument["serviceName"], WiFi.macAddress(), wifiManager->getLocalIP(), FM->readJsonFileValue(offeredServicesPath, serviceNameCached.c_str()));
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                    }
                    else
                    {
                        /*
                        fmsg = formatComMessage(false, true, udpLastReceivedDataDocument["serviceName"], getServiceMAC(udpLastReceivedDataDocument["serviceName"]), getServiceIP(udpLastReceivedDataDocument["serviceName"]).toString() , FM->readJsonFileValue(externalServicesPath, serviceNameCached.c_str()));
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                        */
                    }
                }
                /*
                Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                Serial.println(fmsg);
                Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                //udpControl.sendUdpMessage(formatMessage(false, false, cacheDocument["serviceName"], WiFi.macAddress().c_str(), wifiManager->getLocalIP().c_str(), FM->readJsonFileValue(serviceListPath, serviceNameCached.c_str())).c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                */
            }
            else
            {
                #ifdef J54J6_LOGGING_H
                    logger logging;
                    String message = "Service ";
                    message += serviceNameCached;
                    message += "doesn't exist - return nothing";
                    logging.SFLog(className, "loop", message.c_str(), 1);
                #endif 
            }   
        }
        else if(udpLastReceivedDataDocument["type"] == "answer")
        {
            //nothing to do at this time - you can use getLastData() to receive all data in your function
            return;
        }
        else
        {
            #ifdef J54J6_LOGGING_H
                logger logging;
                const char* cachedType = udpLastReceivedDataDocument["type"];
                String message = "Syntax of UDP Packet is wrong - packet-type: \n!";
                message += "Type: ";
                message += cachedType;
                message += "\n";
                logging.SFLog(className, "loop", message.c_str(), 1);
            #endif
        }
    }
    return;
}

/*
    Inherited overwritten functionalities

    This are very Basic implementations and will be fixed / better implemented later
*/
void ServiceHandler::startClass()
{
    if(this->classDisabled)
    {
        this->classDisabled = false;
        this->beginListen();
    }
    else
    {
        this->beginListen();
    }
}

void ServiceHandler::stopClass()
{
    if(!this->classDisabled)
    {
        this->classDisabled = true;
        this->stopListen();
        Serial.println("locked!");
        return;
    }
}

void ServiceHandler::pauseClass()
{
    this->stopClass();
}

void ServiceHandler::restartClass()
{
    this->startClass();
}

void ServiceHandler::continueClass()
{
    this->startClass();
}