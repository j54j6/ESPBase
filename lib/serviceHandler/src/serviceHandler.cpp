#include "serviceHandler.h"

/*
    Constructor / Destructor
*/

ServiceHandler::ServiceHandler(Filemanager* FM, WiFiManager* wifiManager, int ExpcallIntervall)
{
    this->FM = FM;
    this->wifiManager = wifiManager;
    this->logging = SysLogger(FM, "ServiceHandler");
    this->classControl = new ClassModuleSlave("ServiceHandler", ExpcallIntervall);
    this->addDelay.setBlockTimeInSec(blockTime);
}

ServiceHandler::~ServiceHandler()
{
    this->udpControl.stop();
    this->udpControl.~udpManager();
    this->logging = SysLogger(FM, "ServiceHandler");
}

/*
    Protected functions
*/

String ServiceHandler::formatComMessage(bool request, bool generateId, String serviceName, String MAC, String ip, String port, String id)
{
    /*
    {
        "type": "request",
        "serviceName" : "notSet",
        "mac" : "<<MACAddress>>",
        "ip" : "<<IPAddress>>",
        "servicePort" : "<<port>>"
        "id" : "<<id>>" //id is randomGenerated by millis()+RandomNumber
    }
    */
    long genId = millis() + random(20, 2145895698);
    lastId = genId;

    String output = F("{\"type\" : \"");
    if(request)
    {
        output += F("request");
    }
    else
    {
        output += F("answer");
    }
    output += F("\",");
    output += F("\"serviceName\" : \"");
    output += serviceName;
    output += ("\", ");
    output += ("\"mac\" : \"");
    output += MAC;
    output += F("\", ");
    output += F("\"ip\" : \"");
    output += ip;
    output += F("\", ");
    output += F("\"servicePort\" : \"");
    output += port;
    if(!generateId && id == "n.S")
    {
        output += F("\"");
        output += F("}");
    }
    else
    {
        if(id == "n.S")
        {
            output += F("\",");
            output += F("\"id\" : \"");
            output += genId;
            output += F("\"}");
        }
        else
        {
            output += F("\",");
            output += F("\"id\" : \"");
            output += id;
            output += F("\"}");
        } 
    }
    #ifdef J54J6_SysLogger
        logging.logIt(F("formatMessage"), output.c_str(), 1);
    #endif 
    #ifdef J54J6_SysLogger
        
        logging.logIt(F("formatMessage"), F(""), 1);
        logging.logIt(F("formatMessage"), F("#####Debug#####"), 1);
        logging.logIt(F("formatMessage"), "Request: " + int(request), 1);
        logging.logIt(F("formatMessage"), "GenerateID: " + int(generateId), 1);
        logging.logIt(F("formatMessage"), "ServiceName: " + serviceName, 1);
        logging.logIt(F("formatMessage"), "MAC: " + MAC, 1);
        logging.logIt(F("formatMessage"), "IP: " + ip, 1);
        logging.logIt(F("formatMessage"), "ServicePort: " + port, 1);
        logging.logIt(F("formatMessage"), "ID: " + id, 1);
        logging.logIt(F("formatMessage"), F("#####Debug#####"), 1);
        logging.logIt(F("formatMessage"), F(""), 1);
    #endif 
    return output;
}

String ServiceHandler::getExternalServiceFilename(const char* serviceName, bool fallback)
{
    String cacheName = serviceName;
    cacheName.replace(" ", "");

    String rfilename = externalServicesPath;
    rfilename += cacheName;
    if(fallback)
    {
        rfilename += "-fallback";
    }
    rfilename += ".json";
    rfilename.replace(" ", "");
    return rfilename;
}

bool ServiceHandler::createInternalServicesBasicConfigFile()
{
    FM->mount();
    if(!FM->fExist(offeredServicesPath))
    {
        #ifdef J54J6_SysLogger
            
            logging.logIt(F("createConfigFile"), F("Config File doesn't exist - try to create"), 1);
        #endif 

        if(FM->createFile(offeredServicesPath))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("createConfigFile"), F("File created!"));
            #endif 
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("createConfigFile"), F("Can't create File! - return false"), 2);
            #endif
            return false;
        }

        if(FM->writeJsonFile(offeredServicesPath, serviceConfigBlueprint, 1))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("createConfigFile"), F("Config Fallback written - return true"));
            #endif
            return true;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("createConfigFile"), F("Can't write in File!"));
            #endif
            return false;
        }
        return false;  
    }
    else
    {
        #ifdef J54J6_SysLogger
            
            logging.logIt(F("createConfigFile"), F("File already exist - SKIP!"));
        #endif
        return true;
    }
    return false;
}

void ServiceHandler::handleRequests()
{
    return;
}

ulong ServiceHandler::getLastGeneratedId()
{
    return lastId;
}

StaticJsonDocument<425> ServiceHandler::getLastData()
{
    return udpLastReceivedDataDocument;
}


bool ServiceHandler::verifySelfOfferedService(const char* serviceName)
{
    if(FM->fExist(offeredServicesPath))
    {
        if(FM->checkForKeyInJSONFile(offeredServicesPath, serviceName))
        {
            if(strcmp(FM->readJsonFileValue(offeredServicesPath, serviceName), "") != 0)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("verifySelfOfferedService"), F("Service verified!"), 2);
                #endif
                return true;
            }
            #ifdef J54J6_SysLogger
                logging.logIt(F("verifySelfOfferedService"), "Service" + String(serviceName) + " has no Port!", 2);
            #endif
            return false;
        }
        #ifdef J54J6_SysLogger
            logging.logIt(F("verifySelfOfferedService"), "Service" + String(serviceName) + " is not defined as self Offered!", 2);
        #endif
        return false;
    }
    #ifdef J54J6_SysLogger
        logging.logIt(F("verifySelfOfferedService"), F("There are no selfOffered List file!"), 2);
    #endif
    return false;
}

bool ServiceHandler::verifyExternalOfferedService(const char* serviceName, bool fallback)
{
    #ifdef J54J6_SysLogger
        logging.logIt(F("verifyExternalOfferedService"), "Try to Verify Servicefile for Service: " + String(serviceName), 2);
    #endif
    Serial.println(F("+++++++++++++++++++++++++++FILE+++++++++++++++++++++++++++"));
    Serial.println(FM->readFile(getExternalServiceFilename(serviceName, fallback).c_str()));
    Serial.println(F("+++++++++++++++++++++++++END FILE+++++++++++++++++++++++++"));
    if(FM->fExist(getExternalServiceFilename(serviceName, fallback).c_str()))
    {
        if(FM->checkForKeyInJSONFile(getExternalServiceFilename(serviceName, fallback).c_str(), "ip") && FM->checkForKeyInJSONFile(getExternalServiceFilename(serviceName, fallback).c_str(), "port")) //file has config
        {
            bool ipCorrect = false;
            bool portCorrect = false;
            if(strcmp(FM->readJsonFileValue(getExternalServiceFilename(serviceName, fallback).c_str(), "ip"), "") != 0 && strcmp(FM->readJsonFileValue(getExternalServiceFilename(serviceName, fallback).c_str(), "ip"), " ") != 0)
            {
                ipCorrect = true;
            }
            if(strcmp(FM->readJsonFileValue(getExternalServiceFilename(serviceName, fallback).c_str(), "port"), "") != 0 && strcmp(FM->readJsonFileValue(getExternalServiceFilename(serviceName, fallback).c_str(), "port"), " ") != 0)
            {
                portCorrect = true;
            }

            if(ipCorrect && portCorrect)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("verifySelfOfferedService"), F("Service verified!"), 2);
                #endif
                return true;
            }
            #ifdef J54J6_SysLogger
                logging.logIt(F("verifySelfOfferedService"), "One ore more Values are not Correct set! IP: " + String(int(ipCorrect) + " Port: " + int(portCorrect)) , 2);
            #endif
            return false;
        }
        #ifdef J54J6_SysLogger
            logging.logIt(F("verifySelfOfferedService"), F("One or more keywords are missed!"), 2);
        #endif 
        return false;                
    }
    #ifdef J54J6_SysLogger
        logging.logIt(F("verifySelfOfferedService"), "There is no Configured Service called " + String(serviceName), 2);
    #endif
    return false;
}

void ServiceHandler::lockServiceName(const char* serviceName)
{
    lockedForServiceSearchData* cacheNode = addDelay.getNode(serviceName);
    if(cacheNode == NULL) //create a new node if noone exist
    {
        cacheNode = addDelay.addNewNode(lastAutoAddRequest.serviceName);
    }
    cacheNode->failedSearchTries++; //increment fail counter by one
    autoAddRunning = false;
    autoAddTimeout = 0;
    lastAutoAddRequest.reset();
}

/*
    Public functions
*/

bool ServiceHandler::beginListen()
{
    createInternalServicesBasicConfigFile();
    if(udpControl.begin())
    {
        #ifdef J54J6_SysLogger
            
            logging.logIt(F("beginListen"), F("NetworkIdent Service started"));
        #endif
        return true;
    }
    else
    {
        #ifdef J54J6_SysLogger
            
            logging.logIt(F("beginListen"), F("Can't start NetworkIdent - udpControl return false!"), 2);
        #endif
        return false;
    }
    return false;
}

void ServiceHandler::stopListen()
{
    udpControl.stop();
    #ifdef J54J6_SysLogger
        
        logging.logIt(F("stopListen"), F("UDP Listener stopped"), 0);
    #endif
}

/*
    Service Management
*/

bool ServiceHandler::addService(bool selfOffered, bool fallback, const char* serviceName, const char* port, const char* ip, const char* mac)
{
    logging.logIt(F("AddService"), "Try to Add new Service with following values: serviceName: " + String(serviceName) + ", port: " + String(port) + ", IP: " + String(ip) + ", MAC: " + String(mac), 2);
    if(selfOffered)
    {
        /*
           internal Services path
        */
       FM->begin();
        if(FM->fExist(offeredServicesPath))
        {
            if(checkForService(serviceName))
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("addService"), F("Service already exist - SKIP"), 0);
                #endif 
                return true;
            }
            const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
            StaticJsonDocument<capacity> cacheDocument;

            //cacheDocument = FM->readJsonFile(serviceListPath);
            String data = FM->readFile(offeredServicesPath);

            if(!data.isEmpty())
            {
                deserializeJson(cacheDocument, data);
            }
            cacheDocument[serviceName] = port;

            FM->writeJsonFile(offeredServicesPath, cacheDocument);
            if(FM->checkForKeyInJSONFile(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "ip") && FM->checkForKeyInJSONFile(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "mac") && FM->checkForKeyInJSONFile(getExternalServiceFilename(lastAutoAddRequest.serviceName, true).c_str(), "port")) //file has config
                            {
                return true;
            }
            else
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("addService"), F("An Error occured while adding the Service please check! -  Service can't be added"), 2);
                #endif
                return false;
            }
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("addService"), F("Can't check for Service - ServiceList File doesn't exist!"), 1);
            #endif
            return false;
        }
    }
    else
    {
        /*
            External Services path
        */
        if(strcmp(ip, "0.0.0.0") != 0 && String(serviceName) != "n.S" && String(port) != "-1")
        {
            //create File
            if(!FM->fExist(getExternalServiceFilename(serviceName, fallback).c_str()));
            {
                FM->createFile(getExternalServiceFilename(serviceName, fallback).c_str());
            }
            bool setIp = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "ip", ip);
            bool setMac = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "mac", mac);
            bool setPort = FM->appendJsonKey(this->getExternalServiceFilename(serviceName, fallback).c_str(), "port", port);

            if(!setIp || !setMac || !setPort)
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("addService"), F("One or more parameter can't be saved - create or append has failed!"), 2);
                #endif
                return false;
            }
            else
            {   
                short serviceSuccessfullyAdded = checkForService(serviceName);
                if(serviceSuccessfullyAdded == 2 || serviceSuccessfullyAdded == 3 || serviceSuccessfullyAdded == 4 || serviceSuccessfullyAdded == 5)
                {
                    #ifdef J54J6_SysLogger
                        
                        logging.logIt(F("addService"), F("Service successfully added"));
                    #endif
                    return true;
                }
                else
                {
                    #ifdef J54J6_SysLogger
                        
                        logging.logIt(F("addService"), F("File could not be created! - Can't fnd Service after add process! - return false"), 2);
                    #endif
                    return false;
                }  
            }
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("addService"), F("Can't add Service - one or more parameter not set!"), 1);
            #endif
            return false;
        }   
    }
    return false;
}


bool ServiceHandler::initAutoAdd(const char* serviceName)
{
    logging.logIt(F("initAutoAdd"), F("Start initAutoAdd"), 1);
    if(!FM->fExist(getExternalServiceFilename(serviceName).c_str()))
    {   
        logging.logIt(F("initAutoAdd"), F("Search for new Service - init successful"), 3);
        searchForService(serviceName);
        lastAutoAddRequest.createdAt = millis();
        lastAutoAddRequest.deleteAfter = timeoutAfterAutoAddWillEnd;
        lastAutoAddRequest.id = getLastGeneratedId();
        lastAutoAddRequest.isFallback = false;
        lastAutoAddRequest.searchType = 4;
        lastAutoAddRequest.serviceName = serviceName;
        autoAddRunning = true;
        autoAddTimeout = millis() + timeoutAfterAutoAddWillEnd;
        return true;
    }
    else
    {
        if(!FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
        {   
            logging.logIt(F("initAutoAdd"), F("Search for new Service - init successfull (Create Fallback)"), 3);
            searchForService(serviceName);
            lastAutoAddRequest.createdAt = millis();
            lastAutoAddRequest.deleteAfter = timeoutAfterAutoAddWillEnd;
            lastAutoAddRequest.id = getLastGeneratedId();
            lastAutoAddRequest.isFallback = true;
            lastAutoAddRequest.searchType = 4;
            lastAutoAddRequest.serviceName = serviceName;
            autoAddRunning = true;
            autoAddTimeout = millis() + timeoutAfterAutoAddWillEnd;
            return true;
        }
        else
        {
            logging.logIt(F("initAutoAdd"), F("Main and Backup CFG are already created - check if any config is broken and remove it!"), 3);
            //Check if main config is broken
            if(!verifyExternalOfferedService(serviceName, false))
            {
                logging.logIt(F("initAutoAdd"), F("Main-Config is broken - remove! - try reinit"), 3);
                FM->fDelete(getExternalServiceFilename(serviceName).c_str());
                if(!FM->fExist(getExternalServiceFilename(serviceName).c_str()))
                {
                    logging.logIt(F("initAutoAdd"), F("Successfully removed!"), 3);
                    return initAutoAdd(serviceName);
                }
                else
                {
                    logging.logIt(F("initAutoAdd"), F("Can't remove Main CFG File!"), 4);
                }
            }
            else if(!verifyExternalOfferedService(serviceName, true))
            {
                logging.logIt(F("initAutoAdd"), F("Backup-Config is broken - remove! - try reinit"), 3);
                FM->fDelete(getExternalServiceFilename(serviceName, true).c_str());
                if(!FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
                {
                    logging.logIt(F("initAutoAdd"), F("Successfully removed!"), 3);
                    lastAutoAddRequest.reset();
                    return initAutoAdd(serviceName);
                }
                else
                {
                    logging.logIt(F("initAutoAdd"), F("Can't remove Backup CFG File!"), 4);
                }
            }
            else
            {
                logging.logIt(F("initAutoAdd"), F("Backup and Main Config is correct - User action required!"), 4);
                return false;
            }
            return false;
        }
        return false;
    }
}

short ServiceHandler::runAutoAdd()
{
    udpControl.run();
    if(!autoAddRunning)
    {
        return -2;
    }
    

    //Check if lastAutoRequest was set by initAutoAdd (id = random, searchType = 4)
    if(lastAutoAddRequest.id != -1 && lastAutoAddRequest.searchType == 4)
    {
        StaticJsonDocument<425> lastFetched = getLastData();

        if(!lastFetched.containsKey("id") || !lastFetched.containsKey("serviceName") || !lastFetched.containsKey("ip") || !lastFetched.containsKey("mac") || !lastFetched.containsKey("servicePort"))
        {
            logging.logIt(F("runAutoAdd"), F("Drop packet! - one ore more keys are missing!"), 1);
            return 10; //no correct packet recieved
        }
        else
        {
            logging.logIt(F("runAutoAdd"), F("Useable Packet received!"), 1);
            //lastReceived Packet does contain all needed keys to create a new Service - check for id and serviceName
            String castedLastRequestID = String(lastAutoAddRequest.id);
            String castedLastReceivedID = lastFetched["id"];

            //prepare id's
            castedLastReceivedID.replace(" ", "");
            castedLastRequestID.replace(" ", "");

            if(castedLastReceivedID != castedLastRequestID)
            {
                logging.logIt(F("runAutoAdd"), F("ID's are not Matching - return"), 1);
                return 3; //id is not matching
            }

            String newServiceIp = lastFetched["ip"];
            String newServicePort = lastFetched["servicePort"];
            String newServiceMAC = lastFetched["mac"];
            String newServiceName = lastAutoAddRequest.serviceName;

            logging.logIt(F("runAutoAdd"), "newServiceIP: " + String(newServiceIp), 1);
            logging.logIt(F("runAutoAdd"), "newServicePort: " + String(newServicePort), 1);
            logging.logIt(F("runAutoAdd"), "newServiceMAC: " + String(newServiceMAC), 1);
            logging.logIt(F("runAutoAdd"), "newServiceName: " +String(newServiceName), 1);

            //newServiceIp.replace(".", "");
            if(newServiceIp != "" && newServiceIp != " " && newServicePort != "" && newServicePort != " ") //mac can be senden but is not important //later for esp-now needed so also implemented
            {   
                bool res;
                if(!lastAutoAddRequest.isFallback)
                {
                    logging.logIt(F("runAutoAdd"), F("Try to Add new MainCFG"), 1);
                    //add Service as main CFG
                    res = addService(false, false, lastAutoAddRequest.serviceName, newServicePort.c_str(), newServiceIp.c_str());
                    if(res)
                    {
                        logging.logIt(F("runAutoAdd"), "Free Heap: " + String(ESP.getFreeHeap()));
                        res = verifyService(lastAutoAddRequest.serviceName, false);
                    }
                }
                else
                {
                    //add Service as backup CFG
                    res = addService(false, true, newServiceName.c_str(), newServicePort.c_str(), newServiceIp.c_str());
                    if(res)
                    {
                        res = verifyService(lastAutoAddRequest.serviceName, false, true);
                    }
                }

                if(res)
                {
                    return 1;
                }
                else
                {
                    return 2;
                }
                
            }
            else
            {
                logging.logIt(F("autoAddService"), "Can't add Service - invalid Data: IP: " + String(newServiceIp) + ", Port: " + String(newServicePort) + ", MAC: " + String(newServiceMAC) + ", Name: " + String(newServiceName), 3);
                return 4;
            }
            
        }
    }
    else
    {
        return 0;
    }

}

short ServiceHandler::autoAddService(const char* serviceName)
{
    lockedForServiceSearchData* cacheNode = addDelay.getNode(serviceName);

    if(cacheNode != NULL)
    {
        if(cacheNode->failedSearchTries >= maxServiceSearchTries)
        {
            return 4;
        }
    }
    logging.logIt(F("autoAddService"), F("Start auto Add Service"), 1);
    //set mode start autoAdd or run autoAdd
    if(!autoAddRunning && strcmp(serviceName, "n.S") != 0)
    {
        logging.logIt(F("autoAddService"), F("Auto Add not running"), 1);
        //init autoAdd and send Request
        bool res = initAutoAdd(serviceName);
        
        if(!res)
        {
            logging.logIt(F("autoAddService"), "Can't add Service " + String(serviceName) + "Backup and Main CFG are defined!", 3);
        }
        else
        {
            logging.logIt(F("autoAddService"), F("AutoAdd successfully started"), 3);
        }
    }
    else
    {
        logging.logIt(F("autoAddService"), F("AutoAdd is still running"), 1);
        short state = runAutoAdd();

        switch(state)
        {
            case -2:
                return 0;
            case 1:
                addDelay.addNewNode(lastAutoAddRequest.serviceName);
                autoAddRunning = false;
                autoAddTimeout = 0;
                lastAutoAddRequest.reset();
                logging.logIt(F("autoAddService"), "Service " + String(serviceName) + "Successfully added!", 3);
                return 1;
                break;
            case 2:
            case 4:
                lockServiceName(lastAutoAddRequest.serviceName);
                logging.logIt(F("autoAddService"), "Error while adding Service " + String(lastAutoAddRequest.serviceName) + "!!!", 3);
                return 2;
                break;
            default:
                break;
        }
        return 0; //if nothin received
    }
    return 0;
}

void ServiceHandler::checkForAutoAddTimeout()
{
    if(autoAddRunning)
    {
        if(millis() >= autoAddTimeout)
        {
            autoAddTimeout = 0;
            autoAddRunning = false;
            lastAutoAddRequest.reset();
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("checkForAutoAddTimeout"), F("Timeout reached! - reset autoAdd"), 3);
            #endif
        }
    }
}

bool ServiceHandler::delService(const char* serviceName, bool selfOffered, bool fallback)
{
    if(selfOffered)
    {
        /*
            Delete an internal Service
        */
       if(!FM->fExist(offeredServicesPath))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("delService"), F("Can't delete Service, serviceList doesn't exist!"), 1);
            #endif
            return false;
        }

        if(!checkForService(serviceName))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("delService"), F("Can't delete Service, serviceList doesn't contains the specified Service! - SKIP"), 1);
            #endif
            return true;
        }

        const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
        //DynamicJsonDocument cacheDocument(capacity);
        StaticJsonDocument<capacity> cacheDocument;

        cacheDocument = FM->readJsonFile(offeredServicesPath);

        cacheDocument.remove(serviceName);
        
        if(checkForService(serviceName))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("delService"), F("An Error occured while deleting the Service - please check!"), 2);
            #endif
            return false;
        }
        #ifdef J54J6_SysLogger
            
            logging.logIt(F("delService"), F("Service successfully deleted!"));
        #endif
        return true;
    }
    else
    {
        /*
            delete an external Service
        */
        if(FM->fDelete(getExternalServiceFilename(serviceName, fallback).c_str()))
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("delService"), F("Service removed"));
            #endif
            return true;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("delService"), F("Can't remove Service - function returns false"), 2);
            #endif
        }
    }
    return false;
}


bool ServiceHandler::verifyService(const char* serviceName, bool selfOffered, bool fallback)
{
    if(selfOffered)
    {
        return verifySelfOfferedService(serviceName);
    }
    else
    {
        return verifyExternalOfferedService(serviceName, fallback);
    }
}



/*
    Get Stuff
*/

IPAddress ServiceHandler::getServiceIP(const char* serviceName, bool fallback)
{
    IPAddress returnIp;
    if(!fallback)
    {
        //DynamicJsonDocument cacheDoc(425);
        StaticJsonDocument<425> cacheDoc;
        cacheDoc = FM->readJsonFile(getExternalServiceFilename(serviceName, fallback).c_str());
        String ipCached = cacheDoc["ip"];
        if(returnIp.fromString(ipCached))
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned IP for Service \"");
                message += serviceName;
                message += "\" with IP \"";
                message += returnIp.toString();
                message += "\" - success";
                logging.logIt(F("getServiceIP"), message.c_str());
            #endif 
            return returnIp;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServiceIP"), F("Can't read IP! - return errorIP"), 2);
            #endif 
            return IPAddress(0,0,0,0);
        }
    }
    else
    {
        if(returnIp.fromString(String(FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "ip"))))
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned fallback IP for Service \"");
                message += serviceName;
                message += F("\" with IP \"");
                message += returnIp.toString();
                message += F("\" - success");
                logging.logIt(F("getServiceIP"), message.c_str());
            #endif 
            return returnIp;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServiceIP"), "Can't read fallback IP! for Serivce " + String(serviceName) + " - return errorIP", 2);
            #endif 
            return IPAddress(0,0,0,0);
        }
    }
    return IPAddress(0,0,0,0);
}

String ServiceHandler::getServiceMAC(const char* serviceName, bool fallback)
{
    if(!fallback)
    {   
        String mac = FM->readJsonFileValue(getExternalServiceFilename(serviceName).c_str(), "mac");
        if(mac != "")
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned MAC for Service \"");
                message += serviceName;
                message += F("\" with MAC \"");
                message += mac;
                message += F("\" - success");
                logging.logIt(F("getServiceMAC"), message.c_str());
            #endif 
            return mac;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServiceMAC"), F("Can't read MAC! - return \"failed\""), 2);
            #endif 
            return "failed";
        }
    }
    else
    {
        String mac = FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "mac");
        if(mac != "")
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned MAC for Service \"");
                message += serviceName;
                message += F("\" with MAC \"");
                message += mac;
                message += F("\" - success");
                logging.logIt(F("getServiceMAC"), message.c_str());
            #endif 
            return mac;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServiceMAC"), F("Can't read MAC! - return \"failed\""), 2);
            #endif 
            return "failed";
        }
    }
    return "failed";
}

int ServiceHandler::getServicePort(const char* serviceName, bool fallback, bool selfOffered)
{
    if(selfOffered) //self offered Services - only return the port by reading serviceName Key Value from JSON
    {
        if((FM->fExist(offeredServicesPath) && checkForService(serviceName, false) == 1) || checkForService(serviceName, false) == 4 || checkForService(serviceName, false) == 5)
        {
            String result = FM->readJsonFileValue(offeredServicesPath, serviceName);
            if(result.toInt())
            {
                return result.toInt();
            }
            else
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("getServicePort"), F("Can't read ServicePort (selfOffered)! - return \"failed\""), 2);
                #endif
                return -1;

            }
            
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServicePort"), F("Can't read ServicePort (selfOffered) - offeredServices File doesn't exist or Service doesn't exist! - return \"failed\""), 1);
            #endif
            return -1; //no selfoffered Service found or !
        }
        
    }

    if(!fallback && !selfOffered) //external Service
    {   
        String port = FM->readJsonFileValue(getExternalServiceFilename(serviceName).c_str(), "port");
        if(port != "")
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned Port for Service \"");
                message += serviceName;
                message += F("\" with Port \"");
                message += port;
                message += F("\" - success");
                logging.logIt(F("getServicePort"), message.c_str());
            #endif 
            return port.toInt();
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServicePort"), F("Can't read Port! - return -1"), 2);
            #endif 
            return -1;
        }
    }
    else
    {
        String port = FM->readJsonFileValue(getExternalServiceFilename(serviceName, true).c_str(), "port");
        if(port != "")
        {
            #ifdef J54J6_SysLogger
                
                String message = F("returned Port for Service \"");
                message += serviceName;
                message += F("\" with Port \"");
                message += port;
                message += F("\" - success");
                logging.logIt(F("getServicePort"), message.c_str());
            #endif 
            return port.toInt();
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("getServicePort"), F("Can't read Port! - return -1"), 2);
            #endif 
            return -1;
        }
    }
    return -1;
}

short ServiceHandler::checkForService(const char* serviceName, bool onlyExternal)
{
    short result = 0;

    /*
        Check for internal Service
    */
    if(!onlyExternal)
    {
        logging.logIt(F("checkForService"), F("Check for Service - called!"), 1);
        bool skip = false;
        if(!FM->fExist(offeredServicesPath))
        {
            #ifdef J54J6_SysLogger
                logging.logIt(F("checkForService"), F("Can't check for internal Service - serviceFile doesn't exist! - no Internal"), 1);
            #endif
            skip = true;
        }
        if(!skip)
        {
            #ifdef J54J6_SysLogger
                logging.logIt(F("checkForService"), F("Internal Service defined! - check for defined Service"), 1);
            #endif
            const size_t capacity = JSON_OBJECT_SIZE(25) + 400;
            //DynamicJsonDocument cacheDocument(capacity);
            StaticJsonDocument<capacity> cacheDocument;

            cacheDocument = FM->readJsonFile(offeredServicesPath);
            /*  
                Serial.println(".......................");
                Serial.println(FM->readFile(serviceListPath));
                Serial.println(".......................");
            */  
            if(cacheDocument.containsKey(serviceName))
            {
                #ifdef J54J6_SysLogger
                    
                    String message = F("Service \"");
                    message += serviceName;
                    message += F("\" exist! - result = 1");
                    logging.logIt(F("checkForService"), message.c_str());
                #endif
                result = 1;
            }
            else
            {
                #ifdef J54J6_SysLogger
                    
                    String message = F("Can't find Service \"");
                    message += serviceName;
                    message += F("\" in internalOffered ServiceList");
                    logging.logIt(F("checkForService"), message.c_str());
                #endif
            }
        }
    }

    /*
        Check for external Service
    */

    bool existMainCfg = FM->fExist(getExternalServiceFilename(serviceName, false).c_str());
    bool existBackupCfg = FM->fExist(getExternalServiceFilename(serviceName, true).c_str());
    
    switch(result) //devide into section - self Offered found(1) and not found (0)
    {
        case 0: //no self offered found
            if(existMainCfg && existBackupCfg)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 3"), -1);
                #endif
                return 3;
                break;
            }
            else if(existMainCfg && !existBackupCfg)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 2"), -1);
                #endif
                return 2;
                break;
            }
            else if(!existMainCfg && existBackupCfg)
            {
                FM->move(getExternalServiceFilename(serviceName, true).c_str(), getExternalServiceFilename(serviceName, false).c_str());
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Backup CFG but no main CFG - move Backup to main and return value of newCheck"), 2);
                #endif
                return checkForService(serviceName, onlyExternal);
                break;
            }
            else
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 0"), 2);
                #endif
                return 0;
                break;
            }
        case 1:
            if(existMainCfg && existBackupCfg)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 5"), 2);
                #endif
                return 5;
                break;
            }
            else if(existMainCfg && !existBackupCfg)
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 4"), 2);
                #endif
                return 4;
                break;
            }
            else if(!existMainCfg && existBackupCfg)
            {
                FM->move(getExternalServiceFilename(serviceName, true).c_str(), getExternalServiceFilename(serviceName, false).c_str());
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Backup CFG but no main CFG - move Backup to main and return value of newCheck"), 2);
                #endif
                return checkForService(serviceName, onlyExternal);
                break;
            }
            else
            {
                #ifdef J54J6_SysLogger
                    logging.logIt(F("checkForService"), F("Return 1"), -1);
                #endif
                return 1;
                break;
            }
        default:
            #ifdef J54J6_SysLogger
                
                String message = F("Unexcepted Value -  \"");
                message += result;
                message += F("\" - excepted 0 or 1!: ");
                logging.logIt(F("checkForService"), message.c_str());
            #endif
            classControl->newReport(F("Unexcepted Value!"), 893, 5, true);
    };

    #ifdef J54J6_SysLogger
        String message = F("Return State for Service \"");
        message += serviceName;
        message += F("\": ");
        message += result;
        logging.logIt(F("checkForService"), message.c_str());
    #endif
    return result;
}

bool ServiceHandler::changeConfigValue(const char* serviceName, const char* toChangeKey, const char* newValue, bool changeInternalService, bool changeFallback)
{
    if(changeInternalService)
    {
        /*
            Edit internal Services File (only ServiceName and Port can be changed!)
        */
        if(FM->fExist(offeredServicesPath))
        {
           return FM->changeJsonValueFile(offeredServicesPath, toChangeKey, newValue);
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                logging.logIt(F("changeConfigValue"), F("Can't change Value  File doesn't exist!"), 2);
            #endif
            return false;
        }
    }
    else
    {
        /*
            Edit external Service File
        */
        if(changeFallback)
        {
            /*
                Edit Fallback CFG
            */
            if(FM->fExist(getExternalServiceFilename(serviceName, true).c_str()))
            {
                return FM->changeJsonValueFile(getExternalServiceFilename(serviceName, true).c_str(), toChangeKey, newValue);
            }
            else
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("changeConfigValue"), F("Can't change Value - Fallback file doesn't exist!"), 2);
                #endif
                return false;
            }
        }
        else
        {
            /*
                Edit Main CFG
            */
            if(FM->fExist(getExternalServiceFilename(serviceName, false).c_str()))
            {
                return FM->changeJsonValueFile(getExternalServiceFilename(serviceName, false).c_str(), toChangeKey, newValue);
            }
            else
            {
                #ifdef J54J6_SysLogger
                    
                    logging.logIt(F("changeConfigValue"), F("Can't change Value - Main file doesn't exist!"), 2);
                #endif
                return false;
            }
        }
    }
    return false;
}

void ServiceHandler::searchForService(const char* serviceName, bool generateId, IPAddress ip, int port)
{
    String message;
    if(!generateId)
    {
        message = formatComMessage(true, false, serviceName);
    }
    else
    {
        message = formatComMessage(true, true, serviceName);
    }
    
    udpControl.sendUdpMessage(message.c_str(), ip, port);
}


int ServiceHandler::checkForAction()
{
    //get new Packets if there are new ones - if nothing new there is an empty pack delivered
    udpPacketResolve* lastResolve = udpControl.getLastUDPPacketLoop();

    //If there is any new Data -> Content != NULL -> clean all fragments delivered with the protocol -> in this Case only char until packackgeSize[n] will be readed all other are removed
    if(lastResolve->udpContent != "NULL")
    {
        lastResolve->clean(); //delete fragments at the end of document
    }
    
    //If there are no new Data UDPContent=NULL -> end function
    if(lastResolve->udpContent == "NULL")
    {
        return -1;
    }
    
    //for debug only
    /*
    Serial.println("---------------------------------");
    Serial.println("UDP Content: ");
    Serial.println(lastResolve->udpContent);
    Serial.println("---------------------------------");
    */

    //create a Json Document from the String given in the last Resolve -> result saved in <<error>>
    DeserializationError error = deserializeJson(udpLastReceivedDataDocument, lastResolve->udpContent);

    /*
        This part called if the incoming data doesnt have the correct syntax - most Error showing Serial is "incomplete Input"
        
        In this Case you only get a Warn and the function ends - if you use this port for another thins unlike NetworkIdent you can use the data properly
    */
    if(error)
    {
        #ifdef J54J6_SysLogger
            
            String message = F("Can't parse last UDP Content to Json - Json returned: \n!");
            message += error.c_str();
            message += F("\n");
            logging.logIt(F("loop"), message.c_str(), 1);
        #endif
        return 4;
    }
    else
    {
        //check for any constructions

        /*
            If you are here you have a correct Json Data package received
            

            Basicly this "else" block does:
                First check if the Json Package includes:
                    - serviceName key 
                    - type key
                If this is not included the function will end

                If both keys are existing:
                    Check if the "type" value is "request" or "answer"

                If type is an request (type = "request")
                    First check for own Services the device offer to others
                    If nothing found saved services will be searched - if there is an service Matching <<serviceName>> - this will be sended
                If type is an answer (type = "answer")
                    Check if ID is the same sended by NetworkIdent
                        if true:
                            try to add the new Service data
                        else
                            function ends
                    at last step:
                        Test for Service
        
        */
        if(!udpLastReceivedDataDocument.containsKey("type") || !udpLastReceivedDataDocument.containsKey("serviceName"))
        {
            //If the parsed Document does not contain "type" and "serviceName" - drop the package and end function

            return -1;
        }


        //cache the Servicename to remove space in Names - because of earlier Problems i prevent double Services or basic mistakes
        String serviceNameCached = udpLastReceivedDataDocument["serviceName"];
        serviceNameCached.replace(" ", "");
        

        if(udpLastReceivedDataDocument["type"] == "request")
        {
            /*
                request Section

                First check for self offered Services matching the Json.serviceName
                if not
                check for interal saved addresses matching the json.servername
            */

            if(checkForService(udpLastReceivedDataDocument["serviceName"]) != 0) //Service exist
            {
                #ifdef J54J6_SysLogger               
                    String message = F("Service ");
                    message += serviceNameCached;
                    message += F(" exist - return true");
                    logging.logIt(F("loop"), message.c_str(), 0);
                #endif
                
                String fmsg;

                /*
    	            Request uses ID identification
                */   
                if(udpLastReceivedDataDocument.containsKey("id"))
                {
                    #ifdef J54J6_SysLogger
                        
                        logging.logIt(F("loop"), F("ID will be appended"), -1);
                    #endif
                    short res = checkForService(udpLastReceivedDataDocument["serviceName"]);
                    if(res == 1 || res == 4 || res == 5) //send internal service
                    {
                        fmsg = formatComMessage(false, true, udpLastReceivedDataDocument["serviceName"], WiFi.macAddress(), wifiManager->getLocalIP(), FM->readJsonFileValue(offeredServicesPath, serviceNameCached.c_str()), udpLastReceivedDataDocument["id"]);
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                        #ifdef J54J6_SysLogger
                            
                            logging.logIt(F("loop"), F("Sended Answer Data with internal Service cred."), -1);
                        #endif
                    }
                    else if(res == 2 || res == 3 )//send external service 
                    {
                        
                        fmsg = formatComMessage(false, false, udpLastReceivedDataDocument["serviceName"], getServiceMAC(udpLastReceivedDataDocument["serviceName"]), getServiceIP(udpLastReceivedDataDocument["serviceName"]).toString(), String(getServicePort(udpLastReceivedDataDocument["serviceName"])), udpLastReceivedDataDocument["id"]);
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                        #ifdef J54J6_SysLogger
                            
                            logging.logIt(F("loop"), F("Sended Answer Data with external Service cred."), -1);
                        #endif                 
                    }
                    lastResolve->resetPack();
                    return 2;
                }
                else 
                {
                    #ifdef J54J6_SysLogger
                        
                        logging.logIt(F("loop"), F("ID will generated"), -1);
                    #endif
                    
                    if(checkForService(udpLastReceivedDataDocument["serviceName"]) == 1 || checkForService(udpLastReceivedDataDocument["serviceName"]) == 3)
                    {
                        fmsg = formatComMessage(false, false, udpLastReceivedDataDocument["serviceName"], WiFi.macAddress(), wifiManager->getLocalIP(), FM->readJsonFileValue(offeredServicesPath, serviceNameCached.c_str()));
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                    }
                    else
                    {
                        
                        fmsg = formatComMessage(false, true, udpLastReceivedDataDocument["serviceName"], getServiceMAC(udpLastReceivedDataDocument["serviceName"]), getServiceIP(udpLastReceivedDataDocument["serviceName"]).toString() , FM->readJsonFileValue(externalServicesPath, serviceNameCached.c_str()));
                        udpControl.sendUdpMessage(fmsg.c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                    }
                    lastResolve->resetPack();
                    return 2;
                }
                /*
                Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                Serial.println(fmsg);
                Serial.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
                //udpControl.sendUdpMessage(formatMessage(false, false, cacheDocument["serviceName"], WiFi.macAddress().c_str(), wifiManager->getLocalIP().c_str(), FM->readJsonFileValue(serviceListPath, serviceNameCached.c_str())).c_str(), udpControl.getLastUDPPacketLoop()->remoteIP, this->networkIdentPort);
                */
            }
            else //requested Setvice is not defined on the device!
            {
                #ifdef J54J6_SysLogger
                    
                    String message = F("Service ");
                    message += serviceNameCached;
                    message += F("doesn't exist - return nothing");
                    logging.logIt(F("loop"), message.c_str(), 1);
                    return 2;
                #endif 
            }   
        }
        else if(udpLastReceivedDataDocument["type"] == "answer")
        {
            //nothing to do at this time - you can use getLastData() to receive all data in your function
            return 1;
        }
        else
        {
            #ifdef J54J6_SysLogger
                
                const char* cachedType = udpLastReceivedDataDocument["type"];
                String message = F("Syntax of UDP Packet is wrong - packet-type: \n!");
                message += F("Type: ");
                message += cachedType;
                message += F("\n");
                logging.logIt(F("loop"), message.c_str(), 1);
            #endif
            return 5;
        }
    }
    return -1;
}

void ServiceHandler::loop()
{
    //check for new Packets with UDPControl Class on <<NetworkIdentPort>>
    addDelay.run();
    udpControl.run();
    classControl->run();
    checkForAutoAddTimeout();

    //if this class is Disabled - end function
    if(classDisabled)
    {
        return;
    }
    checkForAction();

    if(autoAddRunning)
    {
        lastAutoAddRequest.loop();
        autoAddService();
    }
}

/*
    Inherited overwritten functionalities

    This are very Basic implementations and will be fixed / better implemented later
*/
void ServiceHandler::startClass()
{
    if(this->classDisabled)
    {
        this->classDisabled = false;
        this->beginListen();
    }
    else
    {
        this->beginListen();
    }
}

void ServiceHandler::stopClass()
{
    if(!this->classDisabled)
    {
        this->classDisabled = true;
        this->stopListen();
        Serial.println(F("locked!"));
        return;
    }
}

void ServiceHandler::restartClass()
{
    this->stopClass();
    this->startClass();
}